Automatic memory management~
||||||
Unreachable memory
||||||
In computer programming, unreachable memory is a block of dynamically allocated memory where the program that allocated the memory no longer has any reachable pointer that refers to it. Similarly, an unreachable object is a dynamically allocated object that has no reachable reference to it. Informally, unreachable memory is dynamic memory that the program cannot reach directly, nor get to by starting at an object it can reach directly, and then following a chain of pointer references.
In dynamic memory allocation implementations that employ a garbage collector, objects are reclaimed after they become unreachable. The garbage collector is able to determine if an object is reachable; any object that is determined to no longer be reachable can be deallocated. Many programming languages (for example, Java, C#, D, Dylan, Julia) use automatic garbage collection.
In contrast, when memory becomes unreachable in dynamic memory allocation implementations that require explicit deallocation, the memory can no longer be explicitly deallocated. Unreachable memory in systems that use manual memory management results in a memory leak.
Some garbage collectors implement weak references. If an object is reachable only through either weak references or chains of references that include a weak reference, then the object is said to be weakly reachable. The garbage collector can treat a weakly reachable object graph as unreachable and deallocate it. (Conversely, references that prevent an object from being garbage collected are called strong references; a weakly reachable object is unreachable by any chain consisting only of strong references.) Some garbage-collected object-oriented languages, such as Java and Python, feature weak references.  The Java package java.lang.ref supports soft, weak and phantom references, resulting in the additional object reachability states softly reachable and phantom reachable.
Unreachable memory (in languages, like C, that do not reclaim) is often associated with software aging.